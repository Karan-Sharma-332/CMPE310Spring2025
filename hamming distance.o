     1                                  ; Hamming Distance Calculator (Bit-Level)
     2                                  ; CMPE 310 Project 1
     3                                  
     4                                  section .data
     5 00000000 456E74657220666972-         prompt1 db "Enter first string: ", 0
     5 00000009 737420737472696E67-
     5 00000012 3A2000             
     6                                      prompt1_len equ $ - prompt1
     7 00000015 456E74657220736563-         prompt2 db "Enter second string: ", 0
     7 0000001E 6F6E6420737472696E-
     7 00000027 673A2000           
     8                                      prompt2_len equ $ - prompt2
     9 0000002B 48616D6D696E672044-         result_msg db "Hamming Distance: ", 0
     9 00000034 697374616E63653A20-
     9 0000003D 00                 
    10                                      result_len equ $ - result_msg
    11 0000003E 0A00                        newline db 10, 0
    12                                      
    13                                  section .bss
    14 00000000 <res 100h>                  string1 resb 256    ; Buffer for first string (255 chars + null)
    15 00000100 <res 100h>                  string2 resb 256    ; Buffer for second string (255 chars + null)
    16 00000200 ????????                    distance resd 1     ; Store the hamming distance
    17 00000204 <res Ah>                    temp resb 10        ; Temp buffer for number output
    18                                  
    19                                  section .text
    20                                  global _start
    21                                  
    22                                  _start:
    23                                      ; Print first prompt
    24 00000000 B804000000                  mov eax, 4          ; sys_write
    25 00000005 BB01000000                  mov ebx, 1          ; stdout
    26 0000000A B9[00000000]                mov ecx, prompt1
    27 0000000F BA15000000                  mov edx, prompt1_len
    28 00000014 CD80                        int 0x80
    29                                  
    30                                      ; Read first string
    31 00000016 B803000000                  mov eax, 3          ; sys_read
    32 0000001B BB00000000                  mov ebx, 0          ; stdin
    33 00000020 B9[00000000]                mov ecx, string1
    34 00000025 BAFF000000                  mov edx, 255        ; max length
    35 0000002A CD80                        int 0x80
    36 0000002C E897000000                  call remove_newline ; Remove trailing newline
    37                                  
    38                                      ; Print second prompt
    39 00000031 B804000000                  mov eax, 4
    40 00000036 BB01000000                  mov ebx, 1
    41 0000003B B9[15000000]                mov ecx, prompt2
    42 00000040 BA16000000                  mov edx, prompt2_len
    43 00000045 CD80                        int 0x80
    44                                  
    45                                      ; Read second string
    46 00000047 B803000000                  mov eax, 3
    47 0000004C BB00000000                  mov ebx, 0
    48 00000051 B9[00010000]                mov ecx, string2
    49 00000056 BAFF000000                  mov edx, 255
    50 0000005B CD80                        int 0x80
    51 0000005D E866000000                  call remove_newline
    52                                  
    53                                      ; Calculate Hamming distance
    54 00000062 31F6                        xor esi, esi        ; Index counter
    55 00000064 31FF                        xor edi, edi        ; Distance counter
    56                                  
    57                                  compare_loop:
    58 00000066 8A86[00000000]              mov al, [string1 + esi]
    59 0000006C 8A9E[00010000]              mov bl, [string2 + esi]
    60                                      
    61                                      ; Check if we reached end of either string
    62 00000072 3C00                        cmp al, 0
    63 00000074 740D                        je end_calc
    64 00000076 80FB00                      cmp bl, 0
    65 00000079 7408                        je end_calc
    66                                      
    67                                      ; Compare characters at bit level
    68 0000007B E8A6000000                  call bit_compare    ; Compare bits of al and bl, adds to edi
    69 00000080 46                          inc esi             ; Move to next character
    70 00000081 EBE3                        jmp compare_loop
    71                                  
    72                                  end_calc:
    73 00000083 893D[00020000]              mov [distance], edi ; Store final distance
    74                                  
    75                                      ; Print result message
    76 00000089 B804000000                  mov eax, 4
    77 0000008E BB01000000                  mov ebx, 1
    78 00000093 B9[2B000000]                mov ecx, result_msg
    79 00000098 BA13000000                  mov edx, result_len
    80 0000009D CD80                        int 0x80
    81                                  
    82                                      ; Convert distance to string and print
    83 0000009F A1[00020000]                mov eax, [distance]
    84 000000A4 E83E000000                  call print_number
    85                                      
    86                                      ; Print newline
    87 000000A9 B804000000                  mov eax, 4
    88 000000AE BB01000000                  mov ebx, 1
    89 000000B3 B9[3E000000]                mov ecx, newline
    90 000000B8 BA01000000                  mov edx, 1
    91 000000BD CD80                        int 0x80
    92                                  
    93                                      ; Exit program
    94 000000BF B801000000                  mov eax, 1          ; sys_exit
    95 000000C4 31DB                        xor ebx, ebx        ; return 0
    96 000000C6 CD80                        int 0x80
    97                                  
    98                                  ; Subroutine to remove newline from input
    99                                  remove_newline:
   100 000000C8 50                          push eax
   101 000000C9 51                          push ecx
   102 000000CA 31C9                        xor ecx, ecx
   103                                  find_nl:
   104 000000CC 8A81[00000000]              mov al, [ecx + string1]
   105 000000D2 3C0A                        cmp al, 10          ; Check for newline
   106 000000D4 7407                        je replace_nl
   107 000000D6 3C00                        cmp al, 0           ; Check for null
   108 000000D8 740A                        je end_remove
   109 000000DA 41                          inc ecx
   110 000000DB EBEF                        jmp find_nl
   111                                  replace_nl:
   112 000000DD C681[00000000]00            mov byte [ecx + string1], 0
   113                                  end_remove:
   114 000000E4 59                          pop ecx
   115 000000E5 58                          pop eax
   116 000000E6 C3                          ret
   117                                  
   118                                  ; Subroutine to print a number
   119                                  print_number:
   120 000000E7 50                          push eax
   121 000000E8 53                          push ebx
   122 000000E9 51                          push ecx
   123 000000EA 52                          push edx
   124                                      
   125 000000EB BB0A000000                  mov ebx, 10         ; Base 10
   126 000000F0 31C9                        xor ecx, ecx        ; Digit counter
   127                                      
   128                                  convert_loop:
   129 000000F2 31D2                        xor edx, edx
   130 000000F4 F7F3                        div ebx             ; Divide by 10
   131 000000F6 80C230                      add dl, '0'         ; Convert to ASCII
   132 000000F9 8891[04020000]              mov [temp + ecx], dl
   133 000000FF 41                          inc ecx
   134 00000100 85C0                        test eax, eax
   135 00000102 75EE                        jnz convert_loop
   136                                      
   137                                      ; Print digits in reverse
   138                                  print_loop:
   139 00000104 49                          dec ecx
   140 00000105 B804000000                  mov eax, 4
   141 0000010A BB01000000                  mov ebx, 1
   142 0000010F 8D89[04020000]              lea ecx, [temp + ecx]
   143 00000115 BA01000000                  mov edx, 1
   144 0000011A CD80                        int 0x80
   145 0000011C 83F900                      cmp ecx, 0
   146 0000011F 7FE3                        jg print_loop
   147                                      
   148 00000121 5A                          pop edx
   149 00000122 59                          pop ecx
   150 00000123 5B                          pop ebx
   151 00000124 58                          pop eax
   152 00000125 C3                          ret
   153                                  
   154                                  ; Subroutine to compare bits of two characters (in al and bl)
   155                                  ; Adds the number of differing bits to edi
   156                                  bit_compare:
   157 00000126 50                          push eax
   158 00000127 53                          push ebx
   159 00000128 51                          push ecx
   160                                      
   161 00000129 30D8                        xor al, bl          ; XOR to find differing bits (1 where bits differ)
   162 0000012B B908000000                  mov ecx, 8          ; 8 bits to check (since we're working with ASCII chars)
   163 00000130 31DB                        xor ebx, ebx        ; Bit counter
   164                                      
   165                                  count_bits:
   166 00000132 D0E0                        shl al, 1           ; Shift left to check each bit
   167 00000134 7301                        jnc next_bit        ; If carry is 0, no difference at this bit
   168 00000136 43                          inc ebx             ; Increment counter if bit differs
   169                                  next_bit:
   170 00000137 E2F9                        loop count_bits     ; Repeat for all 8 bits
   171                                      
   172 00000139 01DF                        add edi, ebx        ; Add bit differences to total distance
   173                                      
   174 0000013B 59                          pop ecx
   175 0000013C 5B                          pop ebx
   176 0000013D 58                          pop eax
   177 0000013E C3                          ret
